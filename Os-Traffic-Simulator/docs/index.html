<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart City OS Simulator (Pro Edition)</title>
    <style>
        /* --- MODERN DASHBOARD THEME --- */
        :root {
            --bg-dark: #0f172a;
            --bg-panel: #1e293b;
            --border: #334155;
            --text-main: #e2e8f0;
            --text-dim: #94a3b8;
            --accent-green: #10b981;
            --accent-blue: #3b82f6;
            --accent-red: #ef4444;
            --accent-yellow: #f59e0b;
            --accent-purple: #8b5cf6;
        }

        body {
            background-color: var(--bg-dark);
            color: var(--text-main);
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        /* SIDEBAR */
        #sidebar {
            width: 380px;
            background: var(--bg-panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            padding: 25px;
            box-shadow: 10px 0 30px rgba(0,0,0,0.3);
            z-index: 100;
            overflow-y: auto;
            flex-shrink: 0;
        }

        /* MAIN VIEW */
        #visualizer-container {
            flex-grow: 1;
            background-color: #020617; /* Very dark slate */
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            overflow: auto;
            padding: 30px;
            background-image: 
                linear-gradient(rgba(255,255,255,0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255,255,255,0.03) 1px, transparent 1px);
            background-size: 40px 40px;
        }

        canvas {
            border-radius: 12px;
            box-shadow: 0 20px 50px rgba(0,0,0,0.6);
            border: 1px solid var(--border);
        }

        /* LOGS */
        #log-window {
            min-height: 150px;
            max-height: 250px;
            background-color: #0f172a;
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 12px;
            overflow-y: auto;
            font-size: 11px;
            font-family: 'Consolas', monospace;
            color: var(--text-dim);
            margin-bottom: 20px;
            box-shadow: inset 0 2px 5px rgba(0,0,0,0.2);
        }

        /* UI ELEMENTS */
        .control-group {
            margin-bottom: 25px;
            background: rgba(255,255,255,0.03);
            border: 1px solid var(--border);
            padding: 15px;
            border-radius: 8px;
        }

        h2 { 
            font-size: 22px; color: #fff; font-weight: 700; letter-spacing: 1px;
            margin-top: 0; margin-bottom: 20px;
            background: linear-gradient(90deg, var(--accent-blue), var(--accent-purple));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        h3 { 
            font-size: 12px; color: var(--text-dim); margin-top: 0; margin-bottom: 15px;
            text-transform: uppercase; letter-spacing: 1px; font-weight: 600;
        }

        /* MODERN BUTTONS */
        button {
            position: relative;
            background: var(--bg-dark);
            color: var(--text-main);
            border: 1px solid var(--border);
            padding: 12px;
            cursor: pointer;
            width: 100%;
            margin-top: 10px;
            font-weight: 600;
            font-size: 13px;
            border-radius: 6px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        button:hover { background: #334155; transform: translateY(-1px); }
        button:active { transform: translateY(1px); }

        button.active {
            background: rgba(16, 185, 129, 0.2);
            border-color: var(--accent-green);
            color: var(--accent-green);
        }

        button.emergency {
            background: rgba(239, 68, 68, 0.1);
            border-color: #7f1d1d;
            color: #fca5a5;
        }
        button.emergency:hover { background: rgba(239, 68, 68, 0.2); border-color: var(--accent-red); color: #fff; }

        button.secondary {
            background: transparent; border: 1px dashed var(--border); color: var(--text-dim);
        }
        button.secondary:hover { border-color: var(--text-dim); color: #fff; background: transparent; }

        /* GRAPH */
        #perf-container {
            width: 800px;
            margin-top: 20px;
            background: var(--bg-panel);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }
        
        #perfCanvas { width: 100%; height: 100px; background: #0f172a; border-radius: 4px; border: 1px solid var(--border); }
        
        .legend { display: flex; justify-content: center; gap: 20px; margin-top: 15px; font-size: 12px; color: var(--text-dim); }
        .dot { width: 10px; height: 10px; border-radius: 3px; display: inline-block; margin-right: 6px; }

        .status-row { display: flex; justify-content: space-between; align-items: center; font-size: 13px; color: var(--text-main); margin-bottom: 10px; }
        .status-val { font-family: 'Consolas', monospace; font-weight: bold; }

        /* DATA TABLE */
        #table-container {
            width: 800px;
            margin-top: 20px;
            background: var(--bg-panel);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 50px;
        }

        table { width: 100%; border-collapse: collapse; font-size: 13px; }
        th { text-align: left; padding: 10px; border-bottom: 1px solid var(--border); color: var(--text-dim); font-size: 11px; text-transform: uppercase; }
        td { padding: 10px; border-bottom: 1px solid #334155; font-family: 'Consolas', monospace; }
        tr:last-child td { border-bottom: none; }
        
        /* Badges */
        .badge { padding: 3px 8px; border-radius: 12px; font-size: 10px; font-weight: bold; font-family: sans-serif; }
        .badge-run { background: rgba(16, 185, 129, 0.2); color: var(--accent-green); }
        .badge-wait { background: rgba(148, 163, 184, 0.2); color: var(--text-dim); }
        .badge-block { background: rgba(239, 68, 68, 0.2); color: var(--accent-red); }
        .badge-ready { background: rgba(245, 158, 11, 0.2); color: var(--accent-yellow); }

        /* Context Switch Pulse */
        @keyframes pulse-cxt { 0% { opacity: 0.3; } 50% { opacity: 1; } 100% { opacity: 0.3; } }
        .cxt-active { color: var(--accent-yellow); animation: pulse-cxt 1s infinite; }
    </style>
</head>
<body>

    <div id="sidebar">
        <h2>Traffic OS Kernel</h2>
        
        <div class="control-group">
            <h3>System Configuration</h3>
            <div class="status-row"><span style="color:var(--text-dim)">Model</span> <span>Many-to-One</span></div>
            <div class="status-row"><span style="color:var(--text-dim)">Algorithm</span> <span>Priority Round Robin</span></div>
            <div class="status-row"><span style="color:var(--text-dim)">Semaphore Cap</span> <span>8</span></div>
        </div>

        <div class="control-group">
            <h3>Thread Status</h3>
            <div class="status-row">
                <span>Context Switch</span>
                <span id="cxt-status" class="status-val" style="color:#555">IDLE</span>
            </div>
            <div style="height:1px; background:var(--border); margin:15px 0;"></div>
            <div class="status-row"><span>North Thread</span> <span id="val-north" class="status-val" style="color:#FF5733">0%</span></div>
            <div class="status-row"><span>East Thread</span> <span id="val-east" class="status-val" style="color:#33FF57">0%</span></div>
            <div class="status-row"><span>South Thread</span> <span id="val-south" class="status-val" style="color:#3357FF">0%</span></div>
            <div class="status-row"><span>West Thread</span> <span id="val-west" class="status-val" style="color:#F3FF33">0%</span></div>
            <div class="status-row"><span>Interrupts</span> <span id="val-amb" class="status-val" style="color:#FF00FF">0%</span></div>
        </div>

        <div id="log-window">[SYSTEM] Kernel Initialized.
[SYSTEM] Starting Threads...</div>

        <div class="control-group">
            <h3>Admin Controls</h3>
            <button id="btn-toggle-rain" onclick="toggleRainMode()">üåßÔ∏è Toggle Rain Mode</button>
            <button class="emergency" onclick="spawnAmbulance()">üö® Spawn Ambulance</button>
            <button class="secondary" onclick="clearLogs()">üóëÔ∏è Clear Logs</button>
        </div>
    </div>

    <div id="visualizer-container">
        <canvas id="simCanvas" width="800" height="600"></canvas>
        
        <div id="perf-container">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px;">
                <h3>CPU Thread Usage</h3>
                <span style="font-size:11px; color:#666">Real-Time Monitor (250ms interval)</span>
            </div>
            <canvas id="perfCanvas" width="800" height="100"></canvas>
            <div class="legend">
                <span><span class="dot" style="background:#FF5733"></span>North</span>
                <span><span class="dot" style="background:#33FF57"></span>East</span>
                <span><span class="dot" style="background:#3357FF"></span>South</span>
                <span><span class="dot" style="background:#F3FF33"></span>West</span>
                <span><span class="dot" style="background:#FF00FF;"></span>Interrupt</span>
            </div>
        </div>

        <div id="table-container">
            <h3 style="margin-bottom:15px">Process Control Block (PCB) Table</h3>
            <table id="pcb-table">
                <thead>
                    <tr>
                        <th>Thread Name</th>
                        <th>Priority</th>
                        <th>State</th>
                        <th>Sem (Queue)</th> 
                        <th>Burst Time</th>
                        <th>Interrupts</th>
                        <th>Throughput</th>
                    </tr>
                </thead>
                <tbody id="pcb-body"></tbody>
            </table>
        </div>
    </div>

    <script>
        // --- CONSTANTS ---
        const CANVAS_WIDTH = 800;
        const CANVAS_HEIGHT = 600;
        
        // --- STATE ---
        const state = {
            lanes: [[], [], [], []], 
            currentGreenLane: 0,
            isRainMode: false,
            carIdCounter: 1,
            remainingTime: 0,
            threadLoad: { north: 0, east: 0, south: 0, west: 0, ambulance: 0 },
            interruptedLane: -1,
            contextSwitching: false,
            stats: {
                0: { name: 'North Controller', priority: 1, state: 'WAITING', burstTime: 0, interrupts: 0, throughput: 0, color: '#FF5733' },
                1: { name: 'East Controller', priority: 1, state: 'WAITING', burstTime: 0, interrupts: 0, throughput: 0, color: '#33FF57' },
                2: { name: 'South Controller', priority: 1, state: 'WAITING', burstTime: 0, interrupts: 0, throughput: 0, color: '#3357FF' },
                3: { name: 'West Controller', priority: 1, state: 'WAITING', burstTime: 0, interrupts: 0, throughput: 0, color: '#F3FF33' },
                4: { name: 'Interrupt Handler', priority: 0, state: 'IDLE', burstTime: 0, interrupts: 0, throughput: 0, color: '#FF00FF' } 
            }
        };

        // --- ASSETS GENERATION ---
        // Dark Asphalt
        const roadPattern = createNoisePattern('#1e293b', '#334155'); 
        // Manicured City Grass
        const grassPattern = createNoisePattern('#064e3b', '#065f46');

        function createNoisePattern(col1, col2) {
            const c = document.createElement('canvas');
            c.width = 100; c.height = 100;
            const x = c.getContext('2d');
            x.fillStyle = col1; x.fillRect(0,0,100,100);
            for(let i=0; i<800; i++) {
                x.fillStyle = col2;
                x.globalAlpha = 0.3;
                x.fillRect(Math.random()*100, Math.random()*100, 2, 2);
            }
            return c;
        }

        // --- LOGGING ---
        const logWindow = document.getElementById('log-window');
        function log(msg) {
            const line = document.createElement('div');
            line.textContent = `> ${msg}`;
            logWindow.appendChild(line);
            logWindow.scrollTop = logWindow.scrollHeight;
        }
        function clearLogs() { logWindow.innerHTML = ''; }

        // --- GENERATOR THREAD ---
        function startGeneratorThread() {
            setInterval(() => {
                [0, 1, 2, 3].forEach(laneIndex => {
                    if (state.lanes[laneIndex].length >= 8) return;
                    if (Math.random() < 0.6) spawnCar(laneIndex, Math.random() < 0.05);
                });
            }, 4000); 
        }

        function spawnCar(laneIndex, isEmergency) {
            const colors = ['#f8fafc', '#facc15', '#3b82f6', '#ef4444', '#10b981', '#f97316', '#a855f7'];
            const color = isEmergency ? '#ffffff' : colors[Math.floor(Math.random() * colors.length)];

            const car = {
                id: state.carIdCounter++,
                isEmergency: isEmergency,
                dir: laneIndex,
                color: color
            };

            if (isEmergency) {
                let insertIdx = 0;
                while (insertIdx < state.lanes[laneIndex].length && state.lanes[laneIndex][insertIdx].isEmergency) {
                    insertIdx++;
                }
                state.lanes[laneIndex].splice(insertIdx, 0, car);
                log(`[SENSOR] üöë AMBULANCE #${car.id} arrived!`);
            } else {
                state.lanes[laneIndex].push(car);
                log(`[SENSOR] Vehicle #${car.id} arrived.`);
            }
        }

        // --- UPDATE HELPERS ---
        function updateThreadState(activeLane, isEmergency) {
            for(let i=0; i<4; i++) {
                if (state.lanes[i].length >= 8) state.stats[i].state = 'BLOCKED (SEM)';
                else state.stats[i].state = 'WAITING';
            }
            state.stats[4].state = 'IDLE';

            if (isEmergency) state.stats[4].state = 'RUNNING';
            else if (activeLane !== -1) state.stats[activeLane].state = 'RUNNING';
        }

        function addBurstTime(lane, seconds) { if (lane >= 0 && lane <= 3) state.stats[lane].burstTime += seconds; }
        function addThroughput(lane) { if (lane >= 0 && lane <= 3) state.stats[lane].throughput += 1; }
        function addInterrupt() { state.stats[4].interrupts += 1; }

        function updateLoad(laneIndex, isEmergency) {
            state.threadLoad = { north: 0, east: 0, south: 0, west: 0, ambulance: 0 };
            updateThreadState(laneIndex, isEmergency);

            if (isEmergency) { state.threadLoad.ambulance = 100; return; }
            
            const val = 60;
            if(laneIndex===0) state.threadLoad.north = val;
            if(laneIndex===1) state.threadLoad.east = val;
            if(laneIndex===2) state.threadLoad.south = val;
            if(laneIndex===3) state.threadLoad.west = val;
        }

        function setContextSwitch(isActive) {
            state.contextSwitching = isActive;
            const el = document.getElementById('cxt-status');
            if(isActive) {
                el.innerText = "SWITCHING...";
                el.className = "status-val cxt-active";
            } else {
                el.innerText = "IDLE";
                el.className = "status-val";
            }
        }

        // --- CONTROLLER THREAD ---
        async function startControllerThread() {
            while (true) {
                updateLoad(-1, false);
                if (state.isRainMode) await sleep(500);

                const laneIndex = state.currentGreenLane;
                const currentLane = state.lanes[laneIndex];

                if (currentLane.length === 0) {
                    const allEmpty = state.lanes.every(l => l.length === 0);
                    if (allEmpty) {
                        state.remainingTime = 0;
                        await sleep(500);
                        continue;
                    }
                    if (state.interruptedLane === -1) {
                        // Simulate Context Switch Overhead
                        setContextSwitch(true);
                        await sleep(200); 
                        setContextSwitch(false);
                        state.currentGreenLane = (state.currentGreenLane + 1) % 4;
                        continue;
                    }
                }

                const GREEN_LIGHT_DURATION = 8000;
                const startTime = Date.now();
                log(`[LIGHT] ${getDirName(laneIndex)} GREEN.`);
                
                let forcedSwitch = false;

                while (Date.now() - startTime < GREEN_LIGHT_DURATION) {
                    updateLoad(laneIndex, false);
                    addBurstTime(laneIndex, 0.1); 

                    const elapsed = Date.now() - startTime;
                    state.remainingTime = Math.ceil((GREEN_LIGHT_DURATION - elapsed) / 1000);

                    // Ambulance Check
                    const isServingAmbulance = state.lanes[laneIndex].length > 0 && state.lanes[laneIndex][0].isEmergency;
                    if (!isServingAmbulance) {
                        let globalBestLane = -1;
                        let minEmergencyID = Infinity;
                        state.lanes.forEach((lane, idx) => {
                            if (lane.length > 0 && lane[0].isEmergency) {
                                if (lane[0].id < minEmergencyID) {
                                    minEmergencyID = lane[0].id;
                                    globalBestLane = idx;
                                }
                            }
                        });
                        if (globalBestLane !== -1 && globalBestLane !== laneIndex) {
                             log(`[INTERRUPT] üöë Priority Interrupt from ${getDirName(globalBestLane)}!`);
                             updateLoad(laneIndex, true); 
                             addInterrupt();
                             if (state.interruptedLane === -1) state.interruptedLane = laneIndex;
                             
                             // Overhead for interrupt
                             setContextSwitch(true);
                             await sleep(300);
                             setContextSwitch(false);

                             state.currentGreenLane = globalBestLane;
                             forcedSwitch = true;
                             break;
                        }
                    }

                    // Empty Lane Timeout
                    if (state.lanes[laneIndex].length === 0) {
                        const waitStart = Date.now();
                        let arrived = false;
                        
                        // Drop load to idle while waiting
                        updateLoad(-1, false);

                        while (Date.now() - waitStart < 2000) {
                            await sleep(100);
                            if (Date.now() - startTime >= GREEN_LIGHT_DURATION) break;
                            
                            let innerBestLane = -1;
                            state.lanes.forEach((lane, idx) => {
                                if (lane.length > 0 && lane[0].isEmergency) innerBestLane = idx;
                            });
                            if (innerBestLane !== -1 && innerBestLane !== laneIndex) {
                                if (state.interruptedLane === -1) state.interruptedLane = laneIndex;
                                updateLoad(laneIndex, true); 
                                addInterrupt();
                                state.currentGreenLane = innerBestLane;
                                forcedSwitch = true;
                                break;
                            }
                            if (state.lanes[laneIndex].length > 0) { arrived = true; break; }
                        }
                        if (forcedSwitch) break;
                        if (!arrived) { log(`[INTERRUPT] Lane Empty Timeout.`); break; }
                    }

                    if (state.lanes[laneIndex].length === 0) break;

                    const car = state.lanes[laneIndex][0];
                    state.lanes[laneIndex].shift();
                    addThroughput(laneIndex);

                    if (car.isEmergency) {
                        updateLoad(laneIndex, true); 
                        await sleep(800); 
                    } else {
                        const delay = state.isRainMode ? 2000 : 1000;
                        await sleep(delay); 
                    }
                }

                state.remainingTime = 0;
                await sleep(500); 
                
                if (!forcedSwitch) {
                    setContextSwitch(true); // Switch overhead
                    await sleep(200);
                    setContextSwitch(false);

                    if (state.interruptedLane !== -1) {
                        log(`[RESUME] Returning context to ${getDirName(state.interruptedLane)}.`);
                        state.currentGreenLane = state.interruptedLane;
                        state.interruptedLane = -1; 
                    } else {
                        state.currentGreenLane = (state.currentGreenLane + 1) % 4;
                    }
                }
            }
        }

        function toggleRainMode() {
            state.isRainMode = !state.isRainMode;
            document.getElementById('btn-toggle-rain').classList.toggle('active');
            const txt = document.getElementById('rain-state-text');
            txt.innerText = state.isRainMode ? 'ON' : 'OFF';
            txt.style.color = state.isRainMode ? '#10b981' : '#555';
            log(state.isRainMode ? '*** RAIN MODE ON ***' : '*** RAIN MODE OFF ***');
        }

        function spawnAmbulance() {
            updateLoad(-1, true); 
            addInterrupt();
            spawnCar(Math.floor(Math.random()*4), true);
        }

        // --- GRAPH & TABLE ---
        const perfCtx = document.getElementById('perfCanvas').getContext('2d');
        const historySize = 200;
        const history = {
            north: new Array(historySize).fill(0),
            east: new Array(historySize).fill(0),
            south: new Array(historySize).fill(0),
            west: new Array(historySize).fill(0),
            ambulance: new Array(historySize).fill(0)
        };
        let lastGraphUpdate = 0;

        function drawStatsTable() {
            const tbody = document.getElementById('pcb-body');
            let html = '';
            for(let i=0; i<=4; i++) {
                const s = state.stats[i];
                let badgeClass = 'badge-wait';
                if(s.state === 'RUNNING') badgeClass = 'badge-run';
                if(s.state === 'READY') badgeClass = 'badge-ready';
                if(s.state.includes('BLOCKED')) badgeClass = 'badge-block';
                
                let semText = '-';
                if (i < 4) semText = `${state.lanes[i].length} / 8`;

                html += `<tr>
                    <td style="color:${s.color}; font-weight:600;">${s.name}</td>
                    <td>${s.priority}</td>
                    <td><span class="badge ${badgeClass}">${s.state}</span></td>
                    <td>${semText}</td>
                    <td>${s.burstTime.toFixed(1)}s</td>
                    <td>${s.interrupts}</td>
                    <td>${s.throughput}</td>
                </tr>`;
            }
            tbody.innerHTML = html;
        }

        function drawPerfGraph(timestamp) {
            if (timestamp - lastGraphUpdate > 250) {
                history.north.push(state.threadLoad.north); history.north.shift();
                history.east.push(state.threadLoad.east); history.east.shift();
                history.south.push(state.threadLoad.south); history.south.shift();
                history.west.push(state.threadLoad.west); history.west.shift();
                history.ambulance.push(state.threadLoad.ambulance); history.ambulance.shift();
                lastGraphUpdate = timestamp;
            }

            document.getElementById('val-north').innerText = state.threadLoad.north + '%';
            document.getElementById('val-east').innerText = state.threadLoad.east + '%';
            document.getElementById('val-south').innerText = state.threadLoad.south + '%';
            document.getElementById('val-west').innerText = state.threadLoad.west + '%';
            document.getElementById('val-amb').innerText = state.threadLoad.ambulance + '%';

            perfCtx.fillStyle = '#0f172a';
            perfCtx.fillRect(0, 0, 800, 100);

            perfCtx.strokeStyle = '#1e293b'; perfCtx.lineWidth = 1; perfCtx.beginPath();
            for(let i=35; i<800; i+=40) { perfCtx.moveTo(i,0); perfCtx.lineTo(i,100); }
            for(let i=0; i<=100; i+=25) { let y = 100 - (i); perfCtx.moveTo(35,y); perfCtx.lineTo(800,y); }
            perfCtx.stroke();

            perfCtx.fillStyle = '#64748b'; perfCtx.font = '10px Consolas'; perfCtx.textAlign = 'right';
            perfCtx.fillText('100%', 30, 10); perfCtx.fillText('50%', 30, 50); perfCtx.fillText('0%', 30, 95);

            drawLine(history.north, '#FF5733'); 
            drawLine(history.east, '#33FF57'); 
            drawLine(history.south, '#3357FF'); 
            drawLine(history.west, '#F3FF33'); 
            drawLine(history.ambulance, '#FF00FF'); 
        }

        function drawLine(data, color) {
            perfCtx.strokeStyle = color; perfCtx.lineWidth = 2; perfCtx.beginPath();
            const step = (800 - 35) / historySize;
            for(let i=0; i<data.length; i++) {
                const x = 35 + (i * step);
                const y = 100 - (data[i]);
                if (i===0) perfCtx.moveTo(x, y); else perfCtx.lineTo(x, y);
            }
            perfCtx.stroke();
        }

        // --- DRAWING ---
        const canvas = document.getElementById('simCanvas');
        const ctx = canvas.getContext('2d');
        let patGrass, patRoad;

        function draw(timestamp) {
            if(!patGrass) patGrass = ctx.createPattern(grassPattern, 'repeat');
            if(!patRoad) patRoad = ctx.createPattern(roadPattern, 'repeat');
            
            ctx.fillStyle = patGrass; ctx.fillRect(0, 0, 800, 600);

            drawBuilding(20, 20, 300, 200); 
            drawBuilding(480, 20, 300, 200); 
            drawBuilding(20, 380, 300, 200); 
            drawBuilding(480, 380, 300, 200); 

            drawRoads();
            drawTrafficLights();

            state.lanes.forEach((queue, laneIndex) => {
                queue.forEach((car, posIndex) => draw3DCar(car, laneIndex, posIndex));
            });

            drawPerfGraph(timestamp);
            drawStatsTable();
            requestAnimationFrame(draw);
        }

        function drawBuilding(x, y, w, h) {
            const height = 40; 
            ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.fillRect(x + 20, y + 20, w, h);
            ctx.fillStyle = '#334155'; ctx.fillRect(x, y + h, w, height); 
            ctx.fillStyle = '#1e293b'; ctx.fillRect(x + w, y, height, h); 
            ctx.fillStyle = '#475569'; ctx.fillRect(x, y, w, h);
            
            ctx.fillStyle = '#334155'; ctx.fillRect(x + 20, y + 20, w - 40, h - 40);
            ctx.fillStyle = 'rgba(255,255,255,0.05)';
            for(let i=0; i<5; i++) ctx.fillRect(x + 30 + i*50, y + 30, 30, 30);
        }

        function drawRoads() {
            ctx.fillStyle = patRoad;
            ctx.fillRect(350, 0, 100, 600); ctx.fillRect(0, 250, 800, 100);
            
            // MUTEX BOX (Critical Section)
            const isGreenActive = state.remainingTime > 0;
            ctx.fillStyle = isGreenActive ? '#334155' : '#1e293b'; 
            ctx.fillRect(350, 250, 100, 100);
            
            // Draw Lock Visual
            ctx.strokeStyle = isGreenActive ? '#ef4444' : '#64748b'; // Red if Locked, Grey if Open
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.strokeRect(355, 255, 90, 90);
            ctx.setLineDash([]);
            
            if(isGreenActive) {
                ctx.fillStyle = '#ef4444'; ctx.font = 'bold 10px sans-serif';
                ctx.fillText("MUTEX LOCKED", 365, 305);
            }

            ctx.strokeStyle = '#eab308'; ctx.lineWidth = 2; ctx.setLineDash([15, 15]);
            ctx.beginPath();
            ctx.moveTo(400, 0); ctx.lineTo(400, 250); ctx.moveTo(400, 350); ctx.lineTo(400, 600);
            ctx.moveTo(0, 300); ctx.lineTo(350, 300); ctx.moveTo(450, 300); ctx.lineTo(800, 300);
            ctx.stroke();
            
            ctx.setLineDash([]); ctx.strokeStyle = '#e2e8f0'; ctx.lineWidth = 6;
            ctx.beginPath();
            ctx.moveTo(350, 250); ctx.lineTo(400, 250); ctx.moveTo(400, 350); ctx.lineTo(450, 350);
            ctx.moveTo(350, 300); ctx.lineTo(350, 350); ctx.moveTo(450, 250); ctx.lineTo(450, 300);
            ctx.stroke();
        }

        function drawTrafficLights() {
            const positions = [{x: 310, y: 210}, {x: 490, y: 210}, {x: 490, y: 390}, {x: 310, y: 390}];
            positions.forEach((pos, idx) => {
                ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.beginPath(); ctx.arc(pos.x+5, pos.y+5, 15, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = '#1e293b'; ctx.beginPath(); ctx.arc(pos.x, pos.y, 18, 0, Math.PI*2); ctx.fill();
                
                const isGreen = state.currentGreenLane === idx;
                const color = isGreen ? '#10b981' : '#ef4444';
                
                ctx.fillStyle = isGreen ? color : '#450a0a'; 
                if (!isGreen) ctx.fillStyle = '#ef4444';

                ctx.beginPath(); ctx.arc(pos.x, pos.y, 12, 0, Math.PI*2); ctx.fill();

                if (isGreen) {
                    ctx.shadowBlur = 20; ctx.shadowColor = color;
                    ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.stroke(); ctx.shadowBlur = 0;
                    if (state.remainingTime > 0) {
                        ctx.fillStyle = '#fff'; ctx.font = 'bold 16px Consolas';
                        ctx.fillText(state.remainingTime, pos.x - 5, pos.y + 5);
                    }
                }
            });
        }

        function draw3DCar(car, laneIndex, queuePos) {
            const spacing = 55; const stopOffset = 70;
            let cx, cy, angle;

            switch(laneIndex) {
                case 0: cx = 375; cy = 250 - stopOffset - (queuePos * spacing); angle = Math.PI; break;
                case 1: cx = 450 + stopOffset + (queuePos * spacing); cy = 275; angle = -Math.PI/2; break;
                case 2: cx = 425; cy = 350 + stopOffset + (queuePos * spacing); angle = 0; break;
                case 3: cx = 350 - stopOffset - (queuePos * spacing); cy = 325; angle = Math.PI/2; break;
            }

            if (cx < -50 || cx > 850 || cy < -50 || cy > 650) return;

            ctx.save(); ctx.translate(cx, cy); ctx.rotate(angle);

            const w = 28; const h = 44; const roofH = 22;
            ctx.fillStyle = 'rgba(0,0,0,0.6)'; ctx.fillRect(-w/2 + 4, -h/2 + 4, w, h);

            ctx.fillStyle = '#0f172a';
            ctx.fillRect(-w/2-2, -h/2+6, 4, 8); ctx.fillRect(w/2-2, -h/2+6, 4, 8);
            ctx.fillRect(-w/2-2, h/2-14, 4, 8); ctx.fillRect(w/2-2, h/2-14, 4, 8);

            const bodyGrad = ctx.createLinearGradient(-w/2, 0, w/2, 0);
            bodyGrad.addColorStop(0, shadeColor(car.color, -30));
            bodyGrad.addColorStop(0.5, car.color);
            bodyGrad.addColorStop(1, shadeColor(car.color, -30));
            
            ctx.fillStyle = bodyGrad;
            roundRect(ctx, -w/2, -h/2, w, h, 6); ctx.fill();

            const roofOffset = -4; 
            ctx.fillStyle = shadeColor(car.color, 20); 
            roundRect(ctx, -w/2 + 3, -h/2 + 10 + roofOffset, w - 6, roofH, 4); ctx.fill();

            ctx.fillStyle = '#0f172a';
            ctx.fillRect(-w/2 + 4, -h/2 + 6 + roofOffset, w - 8, 4); 
            ctx.fillRect(-w/2 + 4, -h/2 + 10 + roofH + roofOffset - 2, w - 8, 3); 

            if (car.isEmergency) {
                ctx.fillStyle = '#ef4444';
                ctx.fillRect(-2, -h/2 + 15 + roofOffset, 4, 12); ctx.fillRect(-6, -h/2 + 19 + roofOffset, 12, 4);
                if (Date.now() % 300 < 150) {
                    ctx.fillStyle = '#3b82f6'; ctx.fillRect(-w/2+2, -h/2+2, 6, 4);
                    ctx.fillStyle = '#ef4444'; ctx.fillRect(w/2-8, -h/2+2, 6, 4);
                } else {
                    ctx.fillStyle = '#ef4444'; ctx.fillRect(-w/2+2, -h/2+2, 6, 4);
                    ctx.fillStyle = '#3b82f6'; ctx.fillRect(w/2-8, -h/2+2, 6, 4);
                }
                
                // Headlight Beams
                ctx.globalAlpha = 0.3;
                ctx.fillStyle = '#fff';
                ctx.beginPath(); ctx.moveTo(-w/2+5, -h/2); ctx.lineTo(-w/2-10, -h/2-60); ctx.lineTo(-w/2+20, -h/2-60); ctx.fill();
                ctx.beginPath(); ctx.moveTo(w/2-5, -h/2); ctx.lineTo(w/2+10, -h/2-60); ctx.lineTo(w/2-20, -h/2-60); ctx.fill();
                ctx.globalAlpha = 1.0;

            } else {
                ctx.fillStyle = '#fef08a';
                ctx.beginPath(); ctx.arc(-w/2+5, -h/2+1, 3, 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.arc(w/2-5, -h/2+1, 3, 0, Math.PI*2); ctx.fill();
            }
            ctx.restore();
        }

        function roundRect(ctx, x, y, w, h, r) {
            ctx.beginPath(); ctx.moveTo(x+r, y); ctx.arcTo(x+w, y, x+w, y+h, r); ctx.arcTo(x+w, y+h, x, y+h, r);
            ctx.arcTo(x, y+h, x, y, r); ctx.arcTo(x, y, x+w, y, r); ctx.closePath();
        }
        function shadeColor(col, percent) {
            var R = parseInt(col.substring(1,3),16); var G = parseInt(col.substring(3,5),16); var B = parseInt(col.substring(5,7),16);
            R = parseInt(R * (100 + percent) / 100); G = parseInt(G * (100 + percent) / 100); B = parseInt(B * (100 + percent) / 100);
            R = (R<255)?R:255; G = (G<255)?G:255; B = (B<255)?B:255;
            var RR = ((R.toString(16).length==1)?"0"+R.toString(16):R.toString(16));
            var GG = ((G.toString(16).length==1)?"0"+G.toString(16):G.toString(16));
            var BB = ((B.toString(16).length==1)?"0"+B.toString(16):B.toString(16));
            return "#"+RR+GG+BB;
        }
        function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }
        function getDirName(i) { return ['NORTH','EAST','SOUTH','WEST'][i]; }

        window.onload = function() {
            log('[INIT] System Ready.');
            startGeneratorThread();
            startControllerThread();
            requestAnimationFrame(draw);
        };
    </script>
</body>
</html>