<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Real-Time Multi-threaded Application Simulator</title>
    <style>
        /* --- "MIDNIGHT OCEAN" THEME (Feel Good Palette) --- */
        :root {
            --bg-dark: #1e1e2e;       /* Deep Blue-Grey */
            --bg-panel: #181825;      /* Darker Panel */
            --border: #313244;        /* Soft Border */
            --text-main: #cdd6f4;     /* Soft White */
            --text-dim: #a6adc8;      /* Muted Text */
            
            /* Pastel Accents for Threads */
            --accent-north: #f38ba8;  /* Soft Red */
            --accent-east: #a6e3a1;   /* Soft Green */
            --accent-south: #89b4fa;  /* Soft Blue */
            --accent-west: #f9e2af;   /* Soft Yellow */
            --accent-intr: #cba6f7;   /* Soft Purple */
            
            --btn-hover: #45475a;
        }

        body {
            background-color: var(--bg-dark);
            color: var(--text-main);
            font-family: 'Segoe UI', 'Roboto', sans-serif;
            margin: 0;
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        /* CUSTOM SCROLLBARS */
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: var(--bg-dark); }
        ::-webkit-scrollbar-thumb { background: var(--border); border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #45475a; }

        /* SIDEBAR */
        #sidebar {
            width: 400px;
            background: var(--bg-panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            padding: 25px;
            box-shadow: 10px 0 30px rgba(0,0,0,0.2);
            z-index: 100;
            overflow-y: auto;
            flex-shrink: 0;
        }

        /* MAIN VIEW */
        #visualizer-container {
            flex-grow: 1;
            background-color: #11111b; 
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            overflow: auto;
            padding: 30px;
            background-image: 
                linear-gradient(rgba(255,255,255,0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255,255,255,0.03) 1px, transparent 1px);
            background-size: 40px 40px;
        }

        canvas {
            border-radius: 12px;
            box-shadow: 0 20px 50px rgba(0,0,0,0.5);
            border: 1px solid var(--border);
        }

        /* LOGS */
        #log-window {
            min-height: 150px;
            max-height: 250px;
            background-color: #11111b;
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 12px;
            overflow-y: auto;
            font-size: 12px;
            font-family: 'Consolas', monospace;
            color: var(--text-dim);
            margin-bottom: 20px;
            box-shadow: inset 0 2px 5px rgba(0,0,0,0.2);
            line-height: 1.4;
        }

        /* UI ELEMENTS */
        .control-group {
            margin-bottom: 25px;
            background: rgba(255,255,255,0.02);
            border: 1px solid var(--border);
            padding: 15px;
            border-radius: 10px;
        }

        h2 { 
            font-size: 20px; color: #fff; font-weight: 700; letter-spacing: 0.5px;
            margin-top: 0; margin-bottom: 20px;
            line-height: 1.3;
            background: linear-gradient(90deg, var(--accent-south), var(--accent-intr));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        h3 { 
            font-size: 13px; color: var(--text-dim); margin-top: 0; margin-bottom: 15px;
            text-transform: uppercase; letter-spacing: 1px; font-weight: 600;
            border-bottom: 1px solid var(--border); padding-bottom: 8px;
        }

        /* BUTTONS */
        button {
            position: relative;
            background: var(--bg-dark);
            color: var(--text-main);
            border: 1px solid var(--border);
            padding: 14px;
            cursor: pointer;
            width: 100%;
            margin-top: 10px;
            font-weight: 600;
            font-size: 13px;
            border-radius: 8px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        button:hover { background: var(--btn-hover); transform: translateY(-1px); }
        button:active { transform: translateY(1px); }

        button.active {
            background: rgba(166, 227, 161, 0.15);
            border-color: var(--accent-east);
            color: var(--accent-east);
        }

        button.emergency {
            background: rgba(243, 139, 168, 0.15);
            border-color: #7f1d1d;
            color: var(--accent-north);
        }
        button.emergency:hover { 
            background: rgba(243, 139, 168, 0.25); 
            border-color: var(--accent-north); 
            color: #fff; 
        }

        button.secondary {
            background: transparent; border: 1px dashed var(--border); color: var(--text-dim);
        }
        button.secondary:hover { border-color: var(--text-dim); color: #fff; background: transparent; }

        /* GRAPH CONTAINER */
        #perf-container {
            width: 800px;
            margin-top: 20px;
            background: var(--bg-panel);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        
        #perfCanvas { 
            width: 100%; 
            height: 180px; 
            background: #000; 
            border-radius: 4px; 
            border: 1px solid #333; 
        }
        
        .graph-desc {
            font-size: 13px; color: var(--text-dim); margin-bottom: 15px;
            display: flex; justify-content: space-between; align-items: flex-end;
        }

        .legend { 
            display: flex; justify-content: center; gap: 20px; margin-top: 15px; 
            font-size: 12px; color: var(--text-dim); flex-wrap: wrap;
        }
        .dot { width: 10px; height: 10px; border-radius: 2px; display: inline-block; margin-right: 6px; }

        .status-row { display: flex; justify-content: space-between; align-items: center; font-size: 13px; color: var(--text-main); margin-bottom: 10px; }
        .status-val { font-family: 'Consolas', monospace; font-weight: bold; }

        /* DATA TABLE */
        #table-container {
            width: 800px;
            margin-top: 20px;
            background: var(--bg-panel);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 50px;
        }

        table { width: 100%; border-collapse: collapse; font-size: 13px; }
        th { 
            text-align: left; padding: 12px; 
            border-bottom: 2px solid var(--border); 
            background: rgba(255,255,255,0.02); /* Subtle header bg */
            color: var(--text-dim); font-size: 11px; text-transform: uppercase; letter-spacing: 1px;
        }
        td { padding: 12px; border-bottom: 1px solid var(--border); font-family: 'Consolas', monospace; color: var(--text-main); }
        tr:last-child td { border-bottom: none; }
        
        /* Badges */
        .badge { padding: 4px 8px; border-radius: 4px; font-size: 11px; font-weight: bold; font-family: sans-serif; }
        .badge-run { background: rgba(166, 227, 161, 0.15); color: var(--accent-east); }
        .badge-wait { background: rgba(147, 153, 178, 0.15); color: var(--text-dim); }
        .badge-block { background: rgba(243, 139, 168, 0.15); color: var(--accent-north); }
        .badge-ready { background: rgba(249, 226, 175, 0.15); color: var(--accent-west); }

        @keyframes pulse-cxt { 0% { opacity: 0.3; } 50% { opacity: 1; } 100% { opacity: 0.3; } }
        .cxt-active { color: var(--accent-west); animation: pulse-cxt 1s infinite; }
    </style>
</head>
<body>

    <div id="sidebar">
        <h2>Real-Time Multi-threaded Application Simulator</h2>
        
        <div class="control-group">
            <h3>System Configuration</h3>
            <div class="status-row"><span style="color:var(--text-dim)">Model</span> <span>Many-to-One</span></div>
            <div class="status-row"><span style="color:var(--text-dim)">Algorithm</span> <span>Priority Round Robin</span></div>
            <div class="status-row"><span style="color:var(--text-dim)">Semaphore Cap</span> <span>8</span></div>
        </div>

        <div class="control-group">
            <h3>Thread Status Monitor</h3>
            <div class="status-row">
                <span>Context Switch</span>
                <span id="cxt-status" class="status-val" style="color:#555">IDLE</span>
            </div>
            <div style="height:1px; background:var(--border); margin:15px 0;"></div>
            <div class="status-row"><span>North Thread</span> <span id="val-north" class="status-val" style="color:var(--accent-north)">0%</span></div>
            <div class="status-row"><span>East Thread</span> <span id="val-east" class="status-val" style="color:var(--accent-east)">0%</span></div>
            <div class="status-row"><span>South Thread</span> <span id="val-south" class="status-val" style="color:var(--accent-south)">0%</span></div>
            <div class="status-row"><span>West Thread</span> <span id="val-west" class="status-val" style="color:var(--accent-west)">0%</span></div>
            <div class="status-row"><span>Interrupts</span> <span id="val-amb" class="status-val" style="color:var(--accent-intr)">0%</span></div>
        </div>

        <div id="log-window">[SYSTEM] Kernel Initialized.
[SYSTEM] Starting Threads...</div>

        <div class="control-group">
            <h3>Admin Controls</h3>
            <button id="btn-toggle-rain" onclick="toggleRainMode()">üåßÔ∏è Toggle Rain Mode</button>
            <button class="emergency" onclick="spawnAmbulance()">üö® Spawn Ambulance</button>
            <button class="secondary" onclick="clearLogs()">üóëÔ∏è Clear Logs</button>
        </div>
    </div>

    <div id="visualizer-container">
        <canvas id="simCanvas" width="800" height="600"></canvas>
        
        <div id="perf-container">
            <div class="graph-desc">
                <div>
                    <h3 style="margin:0; border:none; color:var(--text-main); font-size:16px;">CPU Usage History</h3>
                    <span style="font-size:12px; opacity:0.7;">Real-time thread monitoring (Update: 250ms)</span>
                </div>
                <div style="text-align:right">
                    <div style="font-size:11px">X: Time (60s window)</div>
                    <div style="font-size:11px">Y: Utilization %</div>
                </div>
            </div>
            
            <canvas id="perfCanvas" width="800" height="180"></canvas>
            
            <div class="legend">
                <span><span class="dot" style="background:var(--accent-north)"></span>North</span>
                <span><span class="dot" style="background:var(--accent-east)"></span>East</span>
                <span><span class="dot" style="background:var(--accent-south)"></span>South</span>
                <span><span class="dot" style="background:var(--accent-west)"></span>West</span>
                <span><span class="dot" style="background:var(--accent-intr)"></span>Interrupt</span>
            </div>
        </div>

        <div id="table-container">
            <h3 style="margin-bottom:15px; border-bottom:none;">Process Control Block (PCB) Table</h3>
            <table id="pcb-table">
                <thead>
                    <tr>
                        <th>Thread Name</th>
                        <th>Priority</th>
                        <th>State</th>
                        <th>Sem (Queue)</th> 
                        <th>Burst Time</th>
                        <th>Interrupts</th>
                        <th>Throughput</th>
                    </tr>
                </thead>
                <tbody id="pcb-body"></tbody>
            </table>
        </div>
    </div>

    <script>
        // --- CONSTANTS ---
        const CANVAS_WIDTH = 800;
        const CANVAS_HEIGHT = 600;
        
        // --- STATE ---
        const state = {
            lanes: [[], [], [], []], 
            currentGreenLane: 0,
            isRainMode: false,
            carIdCounter: 1,
            greenStartTime: 0,  // Track when green started for smooth timer
            greenDuration: 0,   // Track duration
            threadLoad: { north: 0, east: 0, south: 0, west: 0, ambulance: 0 },
            interruptedLane: -1,
            contextSwitching: false,
            stats: {
                0: { name: 'North Controller', priority: 1, state: 'WAITING', burstTime: 0, interrupts: 0, throughput: 0, color: '#f38ba8' },
                1: { name: 'East Controller', priority: 1, state: 'WAITING', burstTime: 0, interrupts: 0, throughput: 0, color: '#a6e3a1' },
                2: { name: 'South Controller', priority: 1, state: 'WAITING', burstTime: 0, interrupts: 0, throughput: 0, color: '#89b4fa' },
                3: { name: 'West Controller', priority: 1, state: 'WAITING', burstTime: 0, interrupts: 0, throughput: 0, color: '#f9e2af' },
                4: { name: 'Interrupt Handler', priority: 0, state: 'IDLE', burstTime: 0, interrupts: 0, throughput: 0, color: '#cba6f7' } 
            }
        };

        // --- ASSETS GENERATION ---
        const roadPattern = createNoisePattern('#1e293b', '#313244'); 
        const grassPattern = createNoisePattern('#24273a', '#363a4f'); 

        function createNoisePattern(col1, col2) {
            const c = document.createElement('canvas');
            c.width = 100; c.height = 100;
            const x = c.getContext('2d');
            x.fillStyle = col1; x.fillRect(0,0,100,100);
            for(let i=0; i<800; i++) {
                x.fillStyle = col2;
                x.globalAlpha = 0.3;
                x.fillRect(Math.random()*100, Math.random()*100, 2, 2);
            }
            return c;
        }

        // --- LOGGING ---
        const logWindow = document.getElementById('log-window');
        function log(msg) {
            const line = document.createElement('div');
            line.textContent = `> ${msg}`;
            logWindow.appendChild(line);
            logWindow.scrollTop = logWindow.scrollHeight;
        }
        function clearLogs() { logWindow.innerHTML = ''; }

        // --- GENERATOR THREAD ---
        function startGeneratorThread() {
            setInterval(() => {
                [0, 1, 2, 3].forEach(laneIndex => {
                    if (state.lanes[laneIndex].length >= 8) return;
                    if (Math.random() < 0.6) spawnCar(laneIndex, Math.random() < 0.05);
                });
            }, 4000); 
        }

        function spawnCar(laneIndex, isEmergency) {
            const colors = ['#f5e0dc', '#f9e2af', '#89b4fa', '#f38ba8', '#a6e3a1', '#fab387', '#cba6f7'];
            const color = isEmergency ? '#ffffff' : colors[Math.floor(Math.random() * colors.length)];

            const car = {
                id: state.carIdCounter++,
                isEmergency: isEmergency,
                dir: laneIndex,
                color: color
            };

            if (isEmergency) {
                let insertIdx = 0;
                while (insertIdx < state.lanes[laneIndex].length && state.lanes[laneIndex][insertIdx].isEmergency) {
                    insertIdx++;
                }
                state.lanes[laneIndex].splice(insertIdx, 0, car);
                log(`[SENSOR] üöë AMBULANCE #${car.id} arrived!`);
            } else {
                state.lanes[laneIndex].push(car);
                log(`[SENSOR] Vehicle #${car.id} arrived.`);
            }
        }

        // --- UPDATE HELPERS ---
        function updateThreadState(activeLane, isEmergency) {
            for(let i=0; i<4; i++) {
                if (state.lanes[i].length >= 8) state.stats[i].state = 'BLOCKED (SEM)';
                else state.stats[i].state = 'WAITING';
            }
            state.stats[4].state = 'IDLE';

            if (isEmergency) state.stats[4].state = 'RUNNING';
            else if (activeLane !== -1) state.stats[activeLane].state = 'RUNNING';
        }

        function addBurstTime(lane, seconds) { if (lane >= 0 && lane <= 3) state.stats[lane].burstTime += seconds; }
        function addThroughput(lane) { if (lane >= 0 && lane <= 3) state.stats[lane].throughput += 1; }
        function addInterrupt() { state.stats[4].interrupts += 1; }

        function updateLoad(laneIndex, isEmergency) {
            state.threadLoad = { north: 0, east: 0, south: 0, west: 0, ambulance: 0 };
            updateThreadState(laneIndex, isEmergency);

            if (isEmergency) { state.threadLoad.ambulance = 100; return; }
            
            const val = 60;
            if(laneIndex===0) state.threadLoad.north = val;
            if(laneIndex===1) state.threadLoad.east = val;
            if(laneIndex===2) state.threadLoad.south = val;
            if(laneIndex===3) state.threadLoad.west = val;
        }

        function setContextSwitch(isActive) {
            state.contextSwitching = isActive;
            const el = document.getElementById('cxt-status');
            if(isActive) {
                el.innerText = "SWITCHING...";
                el.className = "status-val cxt-active";
            } else {
                el.innerText = "IDLE";
                el.className = "status-val";
            }
        }

        // --- CONTROLLER THREAD ---
        async function startControllerThread() {
            while (true) {
                updateLoad(-1, false);
                if (state.isRainMode) await sleep(500);

                const laneIndex = state.currentGreenLane;
                const currentLane = state.lanes[laneIndex];

                if (currentLane.length === 0) {
                    const allEmpty = state.lanes.every(l => l.length === 0);
                    if (allEmpty) {
                        state.greenStartTime = 0; // Turn off light
                        await sleep(500);
                        continue;
                    }
                    if (state.interruptedLane === -1) {
                        setContextSwitch(true);
                        await sleep(200); 
                        setContextSwitch(false);
                        state.currentGreenLane = (state.currentGreenLane + 1) % 4;
                        continue;
                    }
                }

                // 9 seconds (9000ms)
                const GREEN_LIGHT_DURATION = 9000;
                const startTime = Date.now();
                
                // --- TIMER SYNC ---
                state.greenStartTime = startTime;
                state.greenDuration = GREEN_LIGHT_DURATION;

                log(`[LIGHT] ${getDirName(laneIndex)} GREEN.`);
                
                let forcedSwitch = false;

                while (Date.now() - startTime < GREEN_LIGHT_DURATION) {
                    updateLoad(laneIndex, false);
                    addBurstTime(laneIndex, 0.1); 

                    // Ambulance Check
                    const isServingAmbulance = state.lanes[laneIndex].length > 0 && state.lanes[laneIndex][0].isEmergency;
                    if (!isServingAmbulance) {
                        let globalBestLane = -1;
                        let minEmergencyID = Infinity;
                        state.lanes.forEach((lane, idx) => {
                            if (lane.length > 0 && lane[0].isEmergency) {
                                if (lane[0].id < minEmergencyID) {
                                    minEmergencyID = lane[0].id;
                                    globalBestLane = idx;
                                }
                            }
                        });
                        if (globalBestLane !== -1 && globalBestLane !== laneIndex) {
                             log(`[INTERRUPT] üöë Priority Interrupt from ${getDirName(globalBestLane)}!`);
                             updateLoad(laneIndex, true); 
                             addInterrupt();
                             if (state.interruptedLane === -1) state.interruptedLane = laneIndex;
                             
                             setContextSwitch(true);
                             await sleep(300);
                             setContextSwitch(false);

                             state.currentGreenLane = globalBestLane;
                             forcedSwitch = true;
                             break;
                        }
                    }

                    // Empty Lane Timeout
                    if (state.lanes[laneIndex].length === 0) {
                        const waitStart = Date.now();
                        let arrived = false;
                        updateLoad(-1, false);

                        while (Date.now() - waitStart < 2000) {
                            await sleep(100);
                            if (Date.now() - startTime >= GREEN_LIGHT_DURATION) break;
                            
                            let innerBestLane = -1;
                            state.lanes.forEach((lane, idx) => {
                                if (lane.length > 0 && lane[0].isEmergency) innerBestLane = idx;
                            });
                            if (innerBestLane !== -1 && innerBestLane !== laneIndex) {
                                if (state.interruptedLane === -1) state.interruptedLane = laneIndex;
                                updateLoad(laneIndex, true); 
                                addInterrupt();
                                state.currentGreenLane = innerBestLane;
                                forcedSwitch = true;
                                break;
                            }
                            if (state.lanes[laneIndex].length > 0) { arrived = true; break; }
                        }
                        if (forcedSwitch) break;
                        if (!arrived) { log(`[INTERRUPT] Lane Empty Timeout.`); break; }
                    }

                    if (state.lanes[laneIndex].length === 0) break;

                    const car = state.lanes[laneIndex][0];
                    state.lanes[laneIndex].shift();
                    addThroughput(laneIndex);

                    if (car.isEmergency) {
                        updateLoad(laneIndex, true); 
                        await sleep(800); 
                    } else {
                        const delay = state.isRainMode ? 2000 : 1000;
                        await sleep(delay); 
                    }
                }

                state.greenStartTime = 0; // Turn off timer visual
                await sleep(500); 
                
                if (!forcedSwitch) {
                    setContextSwitch(true); 
                    await sleep(200);
                    setContextSwitch(false);

                    if (state.interruptedLane !== -1) {
                        log(`[RESUME] Returning context to ${getDirName(state.interruptedLane)}.`);
                        state.currentGreenLane = state.interruptedLane;
                        state.interruptedLane = -1; 
                    } else {
                        state.currentGreenLane = (state.currentGreenLane + 1) % 4;
                    }
                }
            }
        }

        function toggleRainMode() {
            state.isRainMode = !state.isRainMode;
            document.getElementById('btn-toggle-rain').classList.toggle('active');
            const txt = document.getElementById('rain-state-text');
            txt.innerText = state.isRainMode ? 'ON' : 'OFF';
            txt.style.color = state.isRainMode ? 'var(--accent-green)' : 'var(--text-dim)';
            log(state.isRainMode ? '*** RAIN MODE ON ***' : '*** RAIN MODE OFF ***');
        }

        function spawnAmbulance() {
            updateLoad(-1, true); 
            addInterrupt();
            spawnCar(Math.floor(Math.random()*4), true);
        }

        // --- GRAPH & TABLE ---
        const perfCtx = document.getElementById('perfCanvas').getContext('2d');
        const historySize = 200;
        const history = {
            north: new Array(historySize).fill(0),
            east: new Array(historySize).fill(0),
            south: new Array(historySize).fill(0),
            west: new Array(historySize).fill(0),
            ambulance: new Array(historySize).fill(0)
        };
        let lastGraphUpdate = 0;

        function drawStatsTable() {
            const tbody = document.getElementById('pcb-body');
            let html = '';
            for(let i=0; i<=4; i++) {
                const s = state.stats[i];
                let badgeClass = 'badge-wait';
                if(s.state === 'RUNNING') badgeClass = 'badge-run';
                if(s.state === 'READY') badgeClass = 'badge-ready';
                if(s.state.includes('BLOCKED')) badgeClass = 'badge-block';
                
                let semText = '-';
                if (i < 4) semText = `${state.lanes[i].length} / 8`;

                html += `<tr>
                    <td style="color:${s.color}; font-weight:600;">${s.name}</td>
                    <td>${s.priority}</td>
                    <td><span class="badge ${badgeClass}">${s.state}</span></td>
                    <td>${semText}</td>
                    <td>${s.burstTime.toFixed(1)}s</td>
                    <td>${s.interrupts}</td>
                    <td>${s.throughput}</td>
                </tr>`;
            }
            tbody.innerHTML = html;
        }

        function drawPerfGraph(timestamp) {
            if (timestamp - lastGraphUpdate > 250) {
                history.north.push(state.threadLoad.north); history.north.shift();
                history.east.push(state.threadLoad.east); history.east.shift();
                history.south.push(state.threadLoad.south); history.south.shift();
                history.west.push(state.threadLoad.west); history.west.shift();
                history.ambulance.push(state.threadLoad.ambulance); history.ambulance.shift();
                lastGraphUpdate = timestamp;
            }

            document.getElementById('val-north').innerText = state.threadLoad.north + '%';
            document.getElementById('val-east').innerText = state.threadLoad.east + '%';
            document.getElementById('val-south').innerText = state.threadLoad.south + '%';
            document.getElementById('val-west').innerText = state.threadLoad.west + '%';
            document.getElementById('val-amb').innerText = state.threadLoad.ambulance + '%';

            // Darker Background like Task Manager
            perfCtx.fillStyle = '#000000';
            perfCtx.fillRect(0, 0, 800, 180);

            // Task Manager Grid Lines
            perfCtx.lineWidth = 1;
            perfCtx.strokeStyle = '#222'; // Dark Grid
            perfCtx.beginPath();
            
            // Vertical grid lines
            const gridSpacingX = 40;
            for(let x = 0; x < 800; x += gridSpacingX) {
                perfCtx.moveTo(x, 0);
                perfCtx.lineTo(x, 180);
            }
            
            // Horizontal grid lines
            const gridSpacingY = 180 / 4; // 25% increments
            for(let y = 0; y <= 180; y += gridSpacingY) {
                perfCtx.moveTo(0, y);
                perfCtx.lineTo(800, y);
            }
            perfCtx.stroke();

            // Draw Area Filled Lines
            drawAreaLine(history.north, '#f38ba8'); 
            drawAreaLine(history.east, '#a6e3a1'); 
            drawAreaLine(history.south, '#89b4fa'); 
            drawAreaLine(history.west, '#f9e2af'); 
            drawAreaLine(history.ambulance, '#cba6f7'); 
        }

        function drawAreaLine(data, color) {
            const h = 180;
            const step = (800) / historySize; // Use full width
            
            perfCtx.beginPath();
            perfCtx.moveTo(0, h);
            
            for(let i=0; i<data.length; i++) {
                const x = i * step;
                const y = h - (data[i] / 100 * h);
                perfCtx.lineTo(x, y);
            }
            
            perfCtx.lineTo(800, h);
            perfCtx.closePath();
            
            perfCtx.fillStyle = color;
            perfCtx.globalAlpha = 0.2; // Transparency
            perfCtx.fill();
            
            perfCtx.globalAlpha = 1.0;
            perfCtx.strokeStyle = color;
            perfCtx.lineWidth = 2;
            perfCtx.stroke();
        }

        // --- DRAWING ---
        const canvas = document.getElementById('simCanvas');
        const ctx = canvas.getContext('2d');
        let patGrass, patRoad;

        function draw(timestamp) {
            if(!patGrass) patGrass = ctx.createPattern(grassPattern, 'repeat');
            if(!patRoad) patRoad = ctx.createPattern(roadPattern, 'repeat');
            
            ctx.fillStyle = patGrass; ctx.fillRect(0, 0, 800, 600);

            drawBuilding(20, 20, 300, 200); 
            drawBuilding(480, 20, 300, 200); 
            drawBuilding(20, 380, 300, 200); 
            drawBuilding(480, 380, 300, 200); 

            drawRoads();
            drawTrafficLights();

            state.lanes.forEach((queue, laneIndex) => {
                queue.forEach((car, posIndex) => draw3DCar(car, laneIndex, posIndex));
            });

            drawPerfGraph(timestamp);
            drawStatsTable();
            requestAnimationFrame(draw);
        }

        function drawBuilding(x, y, w, h) {
            const height = 40; 
            ctx.fillStyle = 'rgba(0,0,0,0.3)'; ctx.fillRect(x + 20, y + 20, w, h);
            ctx.fillStyle = '#313244'; ctx.fillRect(x, y + h, w, height); 
            ctx.fillStyle = '#1e1e2e'; ctx.fillRect(x + w, y, height, h); 
            ctx.fillStyle = '#45475a'; ctx.fillRect(x, y, w, h);
            
            ctx.fillStyle = '#313244'; ctx.fillRect(x + 20, y + 20, w - 40, h - 40);
            ctx.fillStyle = 'rgba(255,255,255,0.05)';
            for(let i=0; i<5; i++) ctx.fillRect(x + 30 + i*50, y + 30, 30, 30);
        }

        function drawRoads() {
            ctx.fillStyle = patRoad;
            ctx.fillRect(350, 0, 100, 600); ctx.fillRect(0, 250, 800, 100);
            
            // MUTEX BOX (Critical Section)
            const isGreenActive = state.greenStartTime > 0;
            ctx.fillStyle = isGreenActive ? '#313244' : '#1e1e2e'; 
            ctx.fillRect(350, 250, 100, 100);
            
            // Draw Lock Visual
            ctx.strokeStyle = isGreenActive ? '#f38ba8' : '#585b70'; 
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.strokeRect(355, 255, 90, 90);
            ctx.setLineDash([]);
            
            if(isGreenActive) {
                ctx.fillStyle = '#f38ba8'; ctx.font = 'bold 10px sans-serif';
                ctx.fillText("MUTEX LOCKED", 360, 305);
            }

            ctx.strokeStyle = '#f9e2af'; ctx.lineWidth = 2; ctx.setLineDash([15, 15]);
            ctx.beginPath();
            ctx.moveTo(400, 0); ctx.lineTo(400, 250); ctx.moveTo(400, 350); ctx.lineTo(400, 600);
            ctx.moveTo(0, 300); ctx.lineTo(350, 300); ctx.moveTo(450, 300); ctx.lineTo(800, 300);
            ctx.stroke();
            
            ctx.setLineDash([]); ctx.strokeStyle = '#cdd6f4'; ctx.lineWidth = 6;
            // LHT STOP LINES
            ctx.beginPath();
            ctx.moveTo(400, 250); ctx.lineTo(450, 250); // North (Top Right)
            ctx.moveTo(350, 350); ctx.lineTo(400, 350); // South (Bottom Left)
            ctx.moveTo(450, 300); ctx.lineTo(450, 350); // East (Bottom Right)
            ctx.moveTo(350, 250); ctx.lineTo(350, 300); // West (Top Left)
            ctx.stroke();
        }

        function drawTrafficLights() {
            // Updated Light Positions for LHT
            const positions = [
                {x: 490, y: 210}, // North (Top Right)
                {x: 490, y: 390}, // East (Bottom Right)
                {x: 310, y: 390}, // South (Bottom Left)
                {x: 310, y: 210}  // West (Top Left)
            ];

            positions.forEach((pos, idx) => {
                ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.beginPath(); ctx.arc(pos.x+5, pos.y+5, 15, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = '#1e1e2e'; ctx.beginPath(); ctx.arc(pos.x, pos.y, 18, 0, Math.PI*2); ctx.fill();
                
                const isGreen = state.currentGreenLane === idx;
                const color = isGreen ? '#a6e3a1' : '#f38ba8';
                
                ctx.fillStyle = isGreen ? color : '#450a0a'; 
                if (!isGreen) ctx.fillStyle = '#f38ba8';

                ctx.beginPath(); ctx.arc(pos.x, pos.y, 12, 0, Math.PI*2); ctx.fill();

                if (isGreen) {
                    ctx.shadowBlur = 20; ctx.shadowColor = color;
                    ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.stroke(); ctx.shadowBlur = 0;
                    
                    // --- SMOOTH TIMER LOGIC ---
                    if (state.greenStartTime > 0) {
                        const elapsed = Date.now() - state.greenStartTime;
                        const remaining = Math.ceil((state.greenDuration - elapsed) / 1000);
                        if (remaining > 0) {
                            ctx.fillStyle = '#000'; ctx.font = 'bold 16px Consolas';
                            ctx.fillText(remaining, pos.x - 5, pos.y + 5);
                        }
                    }
                }
            });
        }

        function draw3DCar(car, laneIndex, queuePos) {
            const spacing = 55; const stopOffset = 70;
            let cx, cy, angle;

            // UPDATED LHT COORDINATES
            switch(laneIndex) {
                case 0: cx = 425; cy = 250 - stopOffset - (queuePos * spacing); angle = Math.PI; break; // North (Right Side)
                case 1: cx = 450 + stopOffset + (queuePos * spacing); cy = 325; angle = -Math.PI/2; break; // East (Bottom Side)
                case 2: cx = 375; cy = 350 + stopOffset + (queuePos * spacing); angle = 0; break; // South (Left Side)
                case 3: cx = 350 - stopOffset - (queuePos * spacing); cy = 275; angle = Math.PI/2; break; // West (Top Side)
            }

            if (cx < -50 || cx > 850 || cy < -50 || cy > 650) return;

            ctx.save(); ctx.translate(cx, cy); ctx.rotate(angle);

            const w = 28; const h = 44; const roofH = 22;
            ctx.fillStyle = 'rgba(0,0,0,0.4)'; ctx.fillRect(-w/2 + 4, -h/2 + 4, w, h);

            ctx.fillStyle = '#11111b';
            ctx.fillRect(-w/2-2, -h/2+6, 4, 8); ctx.fillRect(w/2-2, -h/2+6, 4, 8);
            ctx.fillRect(-w/2-2, h/2-14, 4, 8); ctx.fillRect(w/2-2, h/2-14, 4, 8);

            const bodyGrad = ctx.createLinearGradient(-w/2, 0, w/2, 0);
            bodyGrad.addColorStop(0, shadeColor(car.color, -30));
            bodyGrad.addColorStop(0.5, car.color);
            bodyGrad.addColorStop(1, shadeColor(car.color, -30));
            
            ctx.fillStyle = bodyGrad;
            roundRect(ctx, -w/2, -h/2, w, h, 6); ctx.fill();

            const roofOffset = -4; 
            ctx.fillStyle = shadeColor(car.color, 20); 
            roundRect(ctx, -w/2 + 3, -h/2 + 10 + roofOffset, w - 6, roofH, 4); ctx.fill();

            ctx.fillStyle = '#11111b';
            ctx.fillRect(-w/2 + 4, -h/2 + 6 + roofOffset, w - 8, 4); 
            ctx.fillRect(-w/2 + 4, -h/2 + 10 + roofH + roofOffset - 2, w - 8, 3); 

            if (car.isEmergency) {
                ctx.fillStyle = '#f38ba8';
                ctx.fillRect(-2, -h/2 + 15 + roofOffset, 4, 12); ctx.fillRect(-6, -h/2 + 19 + roofOffset, 12, 4);
                if (Date.now() % 300 < 150) {
                    ctx.fillStyle = '#89b4fa'; ctx.fillRect(-w/2+2, -h/2+2, 6, 4);
                    ctx.fillStyle = '#f38ba8'; ctx.fillRect(w/2-8, -h/2+2, 6, 4);
                } else {
                    ctx.fillStyle = '#f38ba8'; ctx.fillRect(-w/2+2, -h/2+2, 6, 4);
                    ctx.fillStyle = '#89b4fa'; ctx.fillRect(w/2-8, -h/2+2, 6, 4);
                }
                
                ctx.globalAlpha = 0.3;
                ctx.fillStyle = '#cdd6f4';
                ctx.beginPath(); ctx.moveTo(-w/2+5, -h/2); ctx.lineTo(-w/2-10, -h/2-60); ctx.lineTo(-w/2+20, -h/2-60); ctx.fill();
                ctx.beginPath(); ctx.moveTo(w/2-5, -h/2); ctx.lineTo(w/2+10, -h/2-60); ctx.lineTo(w/2-20, -h/2-60); ctx.fill();
                ctx.globalAlpha = 1.0;

            } else {
                ctx.fillStyle = '#f9e2af';
                ctx.beginPath(); ctx.arc(-w/2+5, -h/2+1, 3, 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.arc(w/2-5, -h/2+1, 3, 0, Math.PI*2); ctx.fill();
            }
            ctx.restore();
        }

        function roundRect(ctx, x, y, w, h, r) {
            ctx.beginPath(); ctx.moveTo(x+r, y); ctx.arcTo(x+w, y, x+w, y+h, r); ctx.arcTo(x+w, y+h, x, y+h, r);
            ctx.arcTo(x, y+h, x, y, r); ctx.arcTo(x, y, x+w, y, r); ctx.closePath();
        }
        function shadeColor(col, percent) {
            var R = parseInt(col.substring(1,3),16); var G = parseInt(col.substring(3,5),16); var B = parseInt(col.substring(5,7),16);
            R = parseInt(R * (100 + percent) / 100); G = parseInt(G * (100 + percent) / 100); B = parseInt(B * (100 + percent) / 100);
            R = (R<255)?R:255; G = (G<255)?G:255; B = (B<255)?B:255;
            var RR = ((R.toString(16).length==1)?"0"+R.toString(16):R.toString(16));
            var GG = ((G.toString(16).length==1)?"0"+G.toString(16):G.toString(16));
            var BB = ((B.toString(16).length==1)?"0"+B.toString(16):B.toString(16));
            return "#"+RR+GG+BB;
        }
        function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }
        function getDirName(i) { return ['NORTH','EAST','SOUTH','WEST'][i]; }

        window.onload = function() {
            log('[INIT] System Ready.');
            startGeneratorThread();
            startControllerThread();
            requestAnimationFrame(draw);
        };
    </script>
</body>
</html>